<?php

// ============================================
// BRIDGE DESIGN PATTERN - COMPLETE REFERENCE
// ============================================

/**
 * WHAT IS BRIDGE PATTERN?
 *
 * The Bridge Pattern separates abstraction from implementation,
 * allowing them to vary independently.
 *
 * REAL-WORLD ANALOGY:
 * Think of a TV remote control:
 * - Remote (Abstraction): Buttons for power, volume, channel
 * - TV (Implementation): Samsung, LG, Sony - each works differently
 * - Same remote can work with different TV brands
 * - Remote doesn't need to know HOW TV changes volume
 * - Remote just says "increase volume", TV handles it
 *
 * ANOTHER ANALOGY:
 * Drawing shapes on different platforms:
 * - Shape (Abstraction): Circle, Square
 * - Platform (Implementation): Windows, Mac, Web
 * - Same Circle code works on Windows, Mac, Web
 * - Platform handles actual drawing
 * - Shape doesn't care HOW platform draws
 *
 * MORE ANALOGIES:
 * - Car transmission (Manual/Auto) + Engine (Diesel/Petrol)
 * - Database query (SQL) + Database (MySQL/PostgreSQL)
 * - Payment method (Credit/Debit) + Gateway (Stripe/PayPal)
 * - Message format (Email/SMS) + Service (SendGrid/Twilio)
 *
 * COMPONENTS:
 * 1. Abstraction: High-level interface
 * 2. Refined Abstraction: Extended abstraction
 * 3. Implementation Interface: Low-level interface
 * 4. Concrete Implementation: Actual implementation
 *
 * WHEN TO USE:
 * - Want to avoid permanent binding between abstraction and implementation
 * - Both abstraction and implementation should be extensible
 * - Changes in implementation shouldn't affect clients
 * - Want to share implementation among multiple objects
 * - Have class explosion from inheritance
 * - Need to switch implementation at runtime
 *
 * WHEN NOT TO USE:
 * - Only one implementation
 * - Abstraction and implementation naturally together
 * - Adds unnecessary complexity
 * - Simple inheritance works fine
 *
 * BENEFITS:
 * ✅ Separates interface from implementation
 * ✅ Improves extensibility (extend independently)
 * ✅ Hides implementation from client
 * ✅ Reduces class explosion
 * ✅ Can change implementation at runtime
 * ✅ Single Responsibility
 * ✅ Open/Closed Principle
 *
 * DRAWBACKS:
 * ❌ Increases complexity
 * ❌ More classes to manage
 * ❌ Harder to understand initially
 * ❌ Indirection adds overhead
 */

// ============================================
// STRUCTURE OF BRIDGE PATTERN
// ============================================

/**
 * PATTERN STRUCTURE:
 *
 * ┌─────────────────────────────────────────┐
 * │       Abstraction                       │
 * ├─────────────────────────────────────────┤
 * │ - implementation: Implementation        │
 * ├─────────────────────────────────────────┤
 * │ + operation()                           │
 * └─────────────────────────────────────────┘
 *                   △
 *                   │ extends
 *        ┌──────────┴──────────┐
 *        │                     │
 * ┌─────────────┐      ┌─────────────┐
 * │ Refined A   │      │ Refined B   │
 * └─────────────┘      └─────────────┘
 *
 *        uses ↓
 *
 * ┌─────────────────────────────────────────┐
 * │    Implementation Interface             │
 * ├─────────────────────────────────────────┤
 * │ + operationImpl()                       │
 * └─────────────────────────────────────────┘
 *                   △
 *                   │ implements
 *        ┌──────────┴──────────┐
 *        │                     │
 * ┌─────────────┐      ┌─────────────┐
 * │ Concrete A  │      │ Concrete B  │
 * └─────────────┘      └─────────────┘
 */

// ============================================
// THE FLOW EXPLAINED
// ============================================

/**
 * HOW BRIDGE PATTERN WORKS - STEP BY STEP:
 *
 * SETUP PHASE:
 * ────────────────────────────────────────
 * 1. Create implementation
 *    → $youtube = new YouTubeAPI()
 *
 * 2. Create abstraction with implementation
 *    → $player = new VideoPlayer($youtube)
 *
 * USAGE PHASE:
 * ────────────────────────────────────────
 * 3. Client calls abstraction
 *    → $player->play()
 *
 * 4. Abstraction delegates to implementation
 *    → $this->implementation->playVideo()
 *
 * 5. Implementation does actual work
 *    → YouTubeAPI->playVideo() // YouTube-specific code
 *
 * SWITCHING IMPLEMENTATION:
 * ────────────────────────────────────────
 * 6. Change implementation at runtime
 *    → $player->setImplementation(new TwitchAPI())
 *
 * 7. Same abstraction, different behavior
 *    → $player->play() // Now uses Twitch!
 *
 * KEY POINTS:
 * ────────────────────────────────────────
 * - Abstraction and implementation separate
 * - Can extend both independently
 * - Client uses abstraction only
 * - Implementation hidden
 */

// ============================================
// KEY CONCEPTS EXPLAINED
// ============================================

/**
 * KEY CONCEPT 1: ABSTRACTION
 * ────────────────────────────────────────
 *
 * WHAT IS IT?
 * High-level control layer (what to do)
 *
 * CHARACTERISTICS:
 * - Has reference to implementation
 * - Defines high-level operations
 * - Delegates to implementation
 * - Doesn't do actual work
 *
 * EXAMPLE:
 * class VideoPlayer {
 *     private $api; // Implementation
 *
 *     public function play() {
 *         $this->api->playVideo(); // Delegate
 *     }
 * }
 *
 * WHY SEPARATE?
 * - Can have multiple abstractions (LivePlayer, RecordedPlayer)
 * - All use same implementations (YouTube, Twitch)
 * - Add new abstraction without changing implementations
 */

/**
 * KEY CONCEPT 2: IMPLEMENTATION
 * ────────────────────────────────────────
 *
 * WHAT IS IT?
 * Low-level platform layer (how to do it)
 *
 * CHARACTERISTICS:
 * - Provides concrete operations
 * - Platform-specific code
 * - Doesn't know about abstraction
 * - Does actual work
 *
 * EXAMPLE:
 * interface VideoAPI {
 *     public function playVideo();
 * }
 *
 * class YouTubeAPI implements VideoAPI {
 *     public function playVideo() {
 *         // YouTube-specific code
 *     }
 * }
 *
 * WHY INTERFACE?
 * - Multiple implementations (YouTube, Twitch, Vimeo)
 * - Abstraction depends on interface, not concrete class
 * - Easy to add new platforms
 */

/**
 * KEY CONCEPT 3: SEPARATION OF CONCERNS
 * ────────────────────────────────────────
 *
 * WITHOUT BRIDGE:
 * YouTubePlayer, YouTubeLivePlayer, YouTubeRecordedPlayer
 * TwitchPlayer, TwitchLivePlayer, TwitchRecordedPlayer
 * VimeoPlayer, VimeoLivePlayer, VimeoRecordedPlayer
 *
 * Result: 3 × 3 = 9 classes! (Class explosion)
 *
 * WITH BRIDGE:
 * Abstractions: Player, LivePlayer, RecordedPlayer (3)
 * Implementations: YouTubeAPI, TwitchAPI, VimeoAPI (3)
 *
 * Result: 3 + 3 = 6 classes! (Much better)
 *
 * FORMULA:
 * Without Bridge: N × M classes
 * With Bridge: N + M classes
 */

/**
 * KEY CONCEPT 4: RUNTIME FLEXIBILITY
 * ────────────────────────────────────────
 *
 * CAN CHANGE IMPLEMENTATION:
 * $player = new VideoPlayer(new YouTubeAPI());
 * $player->play(); // Uses YouTube
 *
 * $player->setImplementation(new TwitchAPI());
 * $player->play(); // Now uses Twitch!
 *
 * BENEFIT:
 * - Same object, different behavior
 * - No need to create new object
 * - Dynamic at runtime
 */

// ============================================
// YOUR USE CASE: VIDEO STREAMING
// ============================================

/**
 * VIDEO STREAMING PLATFORM EXAMPLE
 * ────────────────────────────────────────
 *
 * PROBLEM:
 * - Support multiple video providers (YouTube, Twitch, Vimeo)
 * - Support different quality levels (HD, SD, 4K)
 * - Each provider has different API
 * - Each provider supports different qualities
 * - Don't want class explosion
 *
 * WITHOUT BRIDGE:
 * YouTubeHDPlayer, YouTubeSDPlayer, YouTube4KPlayer
 * TwitchHDPlayer, TwitchSDPlayer
 * VimeoHDPlayer, VimeoSDPlayer, Vimeo4KPlayer
 *
 * 8+ classes! And growing...
 *
 * WITH BRIDGE:
 * Abstraction: VideoPlayer (with quality setting)
 * Implementation: YouTubeAPI, TwitchAPI, VimeoAPI
 *
 * 4 classes total!
 *
 * SOLUTION STRUCTURE:
 * ────────────────────────────────────────
 * Abstraction (What): Video Player
 * - play()
 * - pause()
 * - setQuality(quality)
 *
 * Implementation (How): Video Provider API
 * - YouTubeAPI
 * - TwitchAPI
 * - VimeoAPI
 *
 * Usage:
 * $player = new VideoPlayer(new YouTubeAPI());
 * $player->setQuality('HD');
 * $player->play();
 */

// ============================================
// REAL-WORLD EXAMPLES IN SOFTWARE
// ============================================

/**
 * EXAMPLE 1: DATABASE ABSTRACTION
 * ────────────────────────────────────────
 * Abstraction: Query Builder
 * Implementation: MySQL, PostgreSQL, SQLite
 * - Same query code works on all databases
 *
 * EXAMPLE 2: GUI FRAMEWORKS
 * ────────────────────────────────────────
 * Abstraction: Window, Button
 * Implementation: Windows API, Mac API, Linux API
 * - Same UI code works on all platforms
 *
 * EXAMPLE 3: PAYMENT PROCESSING
 * ────────────────────────────────────────
 * Abstraction: PaymentProcessor
 * Implementation: Stripe, PayPal, Square
 * - Same payment code, different gateways
 *
 * EXAMPLE 4: NOTIFICATION SYSTEM
 * ────────────────────────────────────────
 * Abstraction: Notification
 * Implementation: Email, SMS, Push
 * - Same notification, different channels
 *
 * EXAMPLE 5: FILE STORAGE
 * ────────────────────────────────────────
 * Abstraction: FileManager
 * Implementation: LocalDisk, S3, Dropbox
 * - Same file operations, different storage
 */

// ============================================
// BRIDGE PATTERN IN LARAVEL
// ============================================

/**
 * LARAVEL IMPLEMENTATIONS
 * ────────────────────────────────────────
 *
 * EXAMPLE 1: Database (Built-in Bridge!)
 *
 * // Abstraction: Query Builder
 * DB::table('users')->where('id', 1)->get();
 *
 * // Implementations: MySQL, PostgreSQL, SQLite
 * // Same code works on all databases!
 *
 * EXAMPLE 2: Cache
 *
 * // Abstraction: Cache facade
 * Cache::put('key', 'value', 60);
 *
 * // Implementations: Redis, Memcached, File
 * // Change in config, code stays same
 *
 * EXAMPLE 3: Filesystem
 *
 * // Abstraction: Storage facade
 * Storage::put('file.txt', 'contents');
 *
 * // Implementations: Local, S3, FTP
 * // Same code, different storage
 *
 * EXAMPLE 4: Queue
 *
 * // Abstraction: Queue facade
 * Queue::push(new SendEmail());
 *
 * // Implementations: Redis, Database, SQS
 * // Same code, different queue backend
 *
 * EXAMPLE 5: Broadcasting
 *
 * // Abstraction: Broadcast facade
 * broadcast(new MessageSent());
 *
 * // Implementations: Pusher, Redis, Ably
 * // Same code, different broadcast driver
 */

// ============================================
// COMMON MISTAKES TO AVOID
// ============================================

/**
 * MISTAKE 1: Abstraction Does Too Much
 * ────────────────────────────────────────
 * PROBLEM: Abstraction has platform-specific code
 * SOLUTION: Keep abstraction generic, delegate to implementation
 *
 * MISTAKE 2: Wrong Abstraction Boundary
 * ────────────────────────────────────────
 * PROBLEM: Splitting at wrong level
 * SOLUTION: Think about what varies independently
 *
 * MISTAKE 3: Too Many Methods in Interface
 * ────────────────────────────────────────
 * PROBLEM: Implementation interface too complex
 * SOLUTION: Keep interface focused and minimal
 *
 * MISTAKE 4: Tight Coupling
 * ────────────────────────────────────────
 * PROBLEM: Abstraction knows concrete implementation
 * SOLUTION: Depend on interface, not concrete class
 *
 * MISTAKE 5: Using When Not Needed
 * ────────────────────────────────────────
 * PROBLEM: Overengineering for single implementation
 * SOLUTION: Use only when both dimensions vary
 *
 * MISTAKE 6: Not Using Dependency Injection
 * ────────────────────────────────────────
 * PROBLEM: Abstraction creates implementation
 * SOLUTION: Inject implementation via constructor
 */

// ============================================
// BEST PRACTICES
// ============================================

/**
 * BEST PRACTICE 1: Identify Two Dimensions
 * ────────────────────────────────────────
 * Find what varies independently
 * Abstraction: Business logic
 * Implementation: Platform/technology
 *
 * BEST PRACTICE 2: Keep Interface Minimal
 * ────────────────────────────────────────
 * Implementation interface should be focused
 * Only essential operations
 *
 * BEST PRACTICE 3: Use Dependency Injection
 * ────────────────────────────────────────
 * Inject implementation via constructor
 * Makes testing easier
 *
 * BEST PRACTICE 4: Meaningful Names
 * ────────────────────────────────────────
 * Good: VideoPlayer + YouTubeAPI
 * Bad: Abstraction + Implementation
 *
 * BEST PRACTICE 5: Document Relationship
 * ────────────────────────────────────────
 * Explain why bridge is used
 * What each part is responsible for
 *
 * BEST PRACTICE 6: Test Independently
 * ────────────────────────────────────────
 * Test each implementation separately
 * Mock implementation when testing abstraction
 *
 * BEST PRACTICE 7: Allow Runtime Changes
 * ────────────────────────────────────────
 * Provide setter for implementation
 * Enables flexibility
 *
 * BEST PRACTICE 8: Follow SOLID
 * ────────────────────────────────────────
 * Single Responsibility
 * Open/Closed
 * Dependency Inversion
 */

// ============================================
// COMPARISON WITH OTHER PATTERNS
// ============================================

/**
 * BRIDGE vs ADAPTER
 * ────────────────────────────────────────
 * Bridge: Design upfront, both sides extensible
 * Adapter: Fix existing incompatible interfaces
 * Bridge: Separate abstraction/implementation
 * Adapter: Make two interfaces work together
 *
 * BRIDGE vs STRATEGY
 * ────────────────────────────────────────
 * Bridge: Structural (how classes relate)
 * Strategy: Behavioral (algorithm selection)
 * Bridge: Two hierarchies
 * Strategy: One abstraction, multiple implementations
 *
 * BRIDGE vs ABSTRACT FACTORY
 * ────────────────────────────────────────
 * Bridge: Separate abstraction/implementation
 * Abstract Factory: Create families of objects
 * Can combine: Factory creates implementations for bridge
 *
 * BRIDGE vs STATE
 * ────────────────────────────────────────
 * Bridge: Implementation doesn't change behavior
 * State: Different states, different behavior
 * Bridge: Switch implementation explicitly
 * State: Transitions automatic
 */

// ============================================
// IMPLEMENTATION CHECKLIST
// ============================================

/**
 * CHECKLIST FOR BRIDGE PATTERN:
 * ────────────────────────────────────────
 *
 * □ Identify two varying dimensions
 * □ Create implementation interface
 * □ Define core operations
 * □ Create concrete implementations
 * □ Implement interface for each platform
 * □ Create abstraction class
 * □ Add implementation reference
 * □ Add setter for implementation (optional)
 * □ Delegate operations to implementation
 * □ Create refined abstractions (if needed)
 * □ Test each implementation independently
 * □ Test abstraction with different implementations
 * □ Document bridge structure
 * □ Ensure proper dependency injection
 * □ Keep implementation interface minimal
 *
 * LARAVEL SPECIFIC:
 * ────────────────────────────────────────
 *
 * □ Use service container for injection
 * □ Register implementations in service provider
 * □ Use config for default implementation
 * □ Add interfaces to contracts folder
 * □ Follow Laravel naming conventions
 * □ Write feature tests
 * □ Document in README
 * □ Use type hints
 */

// ============================================
// SUMMARY
// ============================================

/**
 * BRIDGE PATTERN IN ONE PAGE:
 * ────────────────────────────────────────
 *
 * WHAT: Separate abstraction from implementation
 *
 * WHY: Extend both independently, avoid class explosion
 *
 * WHEN: Two dimensions vary independently
 *
 * HOW:
 * 1. Define implementation interface
 * 2. Create concrete implementations
 * 3. Create abstraction with implementation reference
 * 4. Abstraction delegates to implementation
 * 5. Can switch implementation at runtime
 *
 * COMPONENTS:
 * - Abstraction: High-level logic (what)
 * - Implementation: Low-level platform (how)
 * - Both can extend independently
 *
 * BENEFITS:
 * ✅ Reduces class explosion
 * ✅ Separates concerns
 * ✅ Runtime flexibility
 * ✅ Easy to extend
 * ✅ Follows SOLID
 *
 * USE WHEN:
 * ✅ Two dimensions vary
 * ✅ Avoid N×M classes
 * ✅ Need runtime switching
 * ✅ Both sides need extension
 *
 * DON'T USE WHEN:
 * ❌ Single implementation
 * ❌ One dimension varies
 * ❌ Simple inheritance works
 * ❌ Adds unnecessary complexity
 *
 * KEY PRINCIPLE:
 * "Separate what from how"
 *
 * FORMULA:
 * Without Bridge: N × M classes
 * With Bridge: N + M classes
 *
 * REMEMBER:
 * - Abstraction = Business logic
 * - Implementation = Platform/technology
 * - Both extend independently
 * - Client uses abstraction only
 * - Laravel uses this everywhere!
 */
