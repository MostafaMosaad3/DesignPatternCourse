// ============================================
// OBSERVER DESIGN PATTERN
// ============================================

/**
 * WHAT IS OBSERVER PATTERN?
 *
 * The Observer Pattern is a behavioral design pattern where an object (Subject)
 * maintains a list of dependents (Observers) and notifies them automatically
 * when its state changes.
 *
 * REAL-WORLD ANALOGY:
 * Think of YouTube subscriptions:
 * - YouTuber (Subject) posts a new video
 * - All subscribers (Observers) get notified automatically
 * - Subscribers can subscribe or unsubscribe anytime
 * - YouTuber doesn't need to know who the subscribers are
 *
 * ANOTHER ANALOGY:
 * Newspaper subscription:
 * - Newspaper (Subject) publishes daily
 * - Subscribers (Observers) receive it automatically
 * - Can subscribe/unsubscribe anytime
 *
 * MORE ANALOGIES:
 * - Email Newsletter: Publisher sends, subscribers receive
 * - Alarm System: Sensor detects, alerts notify (police, owner, security)
 * - Stock Market: Stock price changes, investors get notified
 * - Social Media: Friend posts, followers see notification
 *
 * COMPONENTS:
 * 1. Subject: The object being watched (the "publisher")
 * 2. Observer: Objects that want to be notified (the "subscribers")
 * 3. ConcreteSubject: Actual implementation of Subject
 * 4. ConcreteObserver: Actual implementation of Observer
 *
 * WHEN TO USE:
 * - When one object changes and others need to react
 * - When you want loose coupling between objects
 * - When you don't know how many objects need to be notified
 * - Event-driven systems
 * - When adding/removing observers should be easy
 * - When multiple objects need to be updated automatically
 *
 * WHEN NOT TO USE:
 * - Simple one-to-one relationships (overkill)
 * - When observers need to know order of execution (observers are independent)
 * - When performance is critical (has slight overhead)
 * - When only 1-2 actions need to happen (just call them directly)
 *
 * BENEFITS:
 * ✅ Loose Coupling: Subject doesn't know about observer details
 * ✅ Open/Closed Principle: Add observers without modifying subject
 * ✅ Single Responsibility: Each observer handles one task
 * ✅ Dynamic Relationships: Add/remove observers at runtime
 * ✅ Broadcast Communication: One event, many listeners
 * ✅ Easy Testing: Test each observer independently
 * ✅ Reusability: Observers can be reused in different contexts
 *
 * DRAWBACKS:
 * ❌ Observers notified in random order (no guaranteed sequence)
 * ❌ Memory leaks if observers not properly detached
 * ❌ Unexpected updates if many observers attached
 * ❌ Debugging can be harder (implicit flow)
 * ❌ Slight performance overhead
 */

// ============================================
// STRUCTURE OF OBSERVER PATTERN
// ============================================

/**
 * PATTERN STRUCTURE:
 *
 * ┌─────────────────────────────────────┐
 * │          Subject Interface          │
 * ├─────────────────────────────────────┤
 * │ + attach(Observer)                  │
 * │ + detach(Observer)                  │
 * │ + notify()                          │
 * └─────────────────────────────────────┘
 *                   △
 *                   │ implements
 *                   │
 * ┌─────────────────────────────────────┐
 * │       ConcreteSubject               │
 * ├─────────────────────────────────────┤
 * │ - observers: Array                  │
 * ├─────────────────────────────────────┤
 * │ + attach(Observer)                  │
 * │ + detach(Observer)                  │
 * │ + notify()                          │
 * │ + getState()                        │
 * │ + setState()                        │
 * └─────────────────────────────────────┘
 *                   │
 *                   │ notifies
 *                   ↓
 * ┌─────────────────────────────────────┐
 * │         Observer Interface          │
 * ├─────────────────────────────────────┤
 * │ + update(Subject)                   │
 * └─────────────────────────────────────┘
 *                   △
 *                   │ implements
 *        ┌──────────┼──────────┐
 *        │          │          │
 * ┌──────────┐ ┌──────────┐ ┌──────────┐
 * │Observer A│ │Observer B│ │Observer C│
 * ├──────────┤ ├──────────┤ ├──────────┤
 * │+update() │ │+update() │ │+update() │
 * └──────────┘ └──────────┘ └──────────┘
 */

// ============================================
// THE FLOW EXPLAINED
// ============================================

/**
 * HOW OBSERVER PATTERN WORKS - STEP BY STEP:
 *
 * SETUP PHASE (happens once):
 * ────────────────────────────
 * 1. Create Subject object
 *    → Has empty observers array: []
 *
 * 2. Create Observer objects
 *    → ObserverA, ObserverB, ObserverC
 *
 * 3. Attach observers to subject
 *    → subject->attach(ObserverA)
 *    → subject->attach(ObserverB)
 *    → subject->attach(ObserverC)
 *    → Now observers array: [ObserverA, ObserverB, ObserverC]
 *
 * NOTIFICATION PHASE (happens when event occurs):
 * ────────────────────────────
 * 4. Event happens (e.g., user registers)
 *    → subject->notify() is called
 *
 * 5. Subject loops through observers array
 *    → foreach ($observers as $observer)
 *
 * 6. Subject calls update() on each observer
 *    → ObserverA->update()  → Does its job
 *    → ObserverB->update()  → Does its job
 *    → ObserverC->update()  → Does its job
 *
 * 7. All observers have been notified
 *    → Process complete!
 *
 * CLEANUP PHASE (optional):
 * ────────────────────────────
 * 8. Detach observers if needed
 *    → subject->detach(ObserverB)
 *    → Now observers array: [ObserverA, ObserverC]
 */

// ============================================
// KEY CONCEPTS EXPLAINED
// ============================================

/**
 * KEY CONCEPT 1: THE SUBJECT
 * ──────────────────────────────
 *
 * WHAT IS IT?
 * The object being watched. The publisher. The broadcaster.
 *
 * WHAT DOES IT DO?
 * - Maintains a list of observers (subscribers)
 * - Provides methods to add/remove observers
 * - Notifies all observers when something happens
 *
 * WHAT DOES IT NOT DO?
 * - Doesn't know what observers do
 * - Doesn't know how many observers exist
 * - Doesn't care about observer implementation details
 *
 * KEY METHODS:
 * - attach(observer): Add observer to list
 * - detach(observer): Remove observer from list
 * - notify(): Tell all observers something happened
 *
 * THINK OF IT AS:
 * A radio station broadcasting to all listeners
 */

/**
 * KEY CONCEPT 2: THE OBSERVER
 * ──────────────────────────────
 *
 * WHAT IS IT?
 * The object watching for changes. The subscriber. The listener.
 *
 * WHAT DOES IT DO?
 * - Implements update() method
 * - Waits to be notified
 * - Reacts when notified
 *
 * WHAT DOES IT NOT DO?
 * - Doesn't know about other observers
 * - Doesn't know about the subject's internal state
 * - Doesn't control when it's notified
 *
 * KEY METHOD:
 * - update(data): Called when subject notifies
 *
 * THINK OF IT AS:
 * A radio listener tuned to the station
 */

/**
 * KEY CONCEPT 3: THE INTERFACE
 * ──────────────────────────────
 *
 * WHY USE INTERFACE?
 * - Ensures all observers have update() method
 * - Makes observers interchangeable
 * - Subject can treat all observers the same way
 * - Follows Dependency Inversion Principle
 *
 * EXAMPLE:
 * interface Observer {
 *     public function update($data): void;
 * }
 *
 * All observers MUST implement this interface!
 */

/**
 * KEY CONCEPT 4: LOOSE COUPLING
 * ──────────────────────────────
 *
 * WHAT IS IT?
 * Subject and observers don't depend on each other's concrete implementations
 *
 * BENEFITS:
 * - Subject doesn't know observer details
 * - Observers don't know subject details
 * - Can change one without affecting the other
 * - Easy to add/remove observers
 *
 * EXAMPLE:
 * Subject knows: "I have observers that implement update()"
 * Subject doesn't know: "What they do inside update()"
 */

// ============================================
// REAL-WORLD EXAMPLES IN SOFTWARE
// ============================================

/**
 * EXAMPLE 1: USER REGISTRATION
 * ────────────────────────────
 * Subject: UserRegistration
 * Event: User registers
 * Observers:
 * - SendWelcomeEmail
 * - LogRegistration
 * - CreateUserProfile
 * - NotifyAdmin
 * - UpdateStatistics
 * - SendToCRM
 *
 * EXAMPLE 2: E-COMMERCE ORDER
 * ────────────────────────────
 * Subject: OrderPlaced
 * Event: Customer places order
 * Observers:
 * - SendOrderConfirmationEmail
 * - UpdateInventory
 * - NotifyWarehouse
 * - CreateInvoice
 * - UpdateAnalytics
 * - SendToShippingPartner
 *
 * EXAMPLE 3: PAYMENT PROCESSING
 * ────────────────────────────
 * Subject: PaymentReceived
 * Event: Payment successful
 * Observers:
 * - SendReceipt
 * - UpdateAccountBalance
 * - LogTransaction
 * - NotifyAccountant
 * - TriggerFulfillment
 *
 * EXAMPLE 4: SOCIAL MEDIA
 * ────────────────────────────
 * Subject: UserPostedContent
 * Event: User posts status
 * Observers:
 * - NotifyFollowers
 * - UpdateTimeline
 * - IndexForSearch
 * - CheckForModeration
 * - UpdateActivityFeed
 *
 * EXAMPLE 5: STOCK TRADING
 * ────────────────────────────
 * Subject: StockPriceChanged
 * Event: Stock price updates
 * Observers:
 * - NotifyInvestors
 * - UpdatePortfolio
 * - TriggerAlerts
 * - LogPriceHistory
 * - CheckTradingRules
 */

// ============================================
// OBSERVER PATTERN IN LARAVEL
// ============================================

/**
 * LARAVEL'S IMPLEMENTATION: EVENTS & LISTENERS
 * ────────────────────────────
 *
 * Laravel has built-in Observer Pattern support!
 *
 * MAPPING:
 * Observer Pattern    →    Laravel
 * ─────────────────────────────────
 * Subject            →    Event
 * Observer           →    Listener
 * attach()           →    Event Registration
 * notify()           →    event() / dispatch()
 * update()           →    handle()
 *
 * EXAMPLE:
 *
 * // Event (Subject)
 * class UserRegistered {
 *     public User $user;
 * }
 *
 * // Listener (Observer)
 * class SendWelcomeEmail {
 *     public function handle(UserRegistered $event) {
 *         // Send email
 *     }
 * }
 *
 * // Register in EventServiceProvider
 * protected $listen = [
 *     UserRegistered::class => [
 *         SendWelcomeEmail::class,
 *         LogRegistration::class,
 *     ],
 * ];
 *
 * // Fire event (notify)
 * event(new UserRegistered($user));
 *
 * BONUS: Laravel Queued Listeners
 * ────────────────────────────
 * Implement ShouldQueue to run observers asynchronously:
 *
 * class SendWelcomeEmail implements ShouldQueue {
 *     public function handle(UserRegistered $event) {
 *         // Runs in background!
 *     }
 * }
 */

// ============================================
// LARAVEL MODEL OBSERVERS
// ============================================

/**
 * LARAVEL MODEL OBSERVERS
 * ────────────────────────────
 *
 * Laravel also has built-in Model Observers for Eloquent!
 *
 * EXAMPLE:
 *
 * // Create observer
 * php artisan make:observer UserObserver --model=User
 *
 * // Observer class
 * class UserObserver {
 *     public function created(User $user) {
 *         // Called after user created
 *     }
 *
 *     public function updated(User $user) {
 *         // Called after user updated
 *     }
 *
 *     public function deleted(User $user) {
 *         // Called after user deleted
 *     }
 * }
 *
 * // Register in AppServiceProvider
 * public function boot() {
 *     User::observe(UserObserver::class);
 * }
 *
 * HOOKS AVAILABLE:
 * - creating / created
 * - updating / updated
 * - saving / saved
 * - deleting / deleted
 * - restoring / restored
 * - retrieved
 */

// ============================================
// COMMON MISTAKES TO AVOID
// ============================================

/**
 * MISTAKE 1: Forgetting to Detach Observers
 * ────────────────────────────
 * PROBLEM: Memory leaks, observers keep running
 * SOLUTION: Always detach when no longer needed
 *
 * MISTAKE 2: Observers Depending on Each Other
 * ────────────────────────────
 * PROBLEM: Order matters, hard to maintain
 * SOLUTION: Keep observers independent
 *
 * MISTAKE 3: Heavy Logic in Observers
 * ────────────────────────────
 * PROBLEM: Slow notifications, blocks execution
 * SOLUTION: Keep observers light, use queues for heavy tasks
 *
 * MISTAKE 4: Not Using Interfaces
 * ────────────────────────────
 * PROBLEM: Tight coupling, hard to test
 * SOLUTION: Always use Observer interface
 *
 * MISTAKE 5: Circular Dependencies
 * ────────────────────────────
 * PROBLEM: Observer notifies subject, infinite loop
 * SOLUTION: Design clear one-way relationships
 *
 * MISTAKE 6: Too Many Observers
 * ────────────────────────────
 * PROBLEM: Hard to debug, performance issues
 * SOLUTION: Keep it reasonable (5-10 observers max)
 *
 * MISTAKE 7: Observers Throwing Exceptions
 * ────────────────────────────
 * PROBLEM: One failure stops all others
 * SOLUTION: Use try-catch in notify() loop
 */

// ============================================
// BEST PRACTICES
// ============================================

/**
 * BEST PRACTICE 1: Keep Observers Independent
 * ────────────────────────────
 * Each observer should work without knowing about others
 *
 * BEST PRACTICE 2: Use Meaningful Names
 * ────────────────────────────
 * Good: SendWelcomeEmailObserver
 * Bad: Observer1, ObserverA
 *
 * BEST PRACTICE 3: Single Responsibility
 * ────────────────────────────
 * Each observer should do ONE thing only
 *
 * BEST PRACTICE 4: Use Queues for Slow Tasks
 * ────────────────────────────
 * If observer takes time (API calls, emails), queue it
 *
 * BEST PRACTICE 5: Document Observer Purpose
 * ────────────────────────────
 * Add comments explaining what each observer does
 *
 * BEST PRACTICE 6: Test Each Observer Separately
 * ────────────────────────────
 * Unit test observers independently from subject
 *
 * BEST PRACTICE 7: Use Type Hints
 * ────────────────────────────
 * Specify parameter types for better code quality
 *
 * BEST PRACTICE 8: Handle Errors Gracefully
 * ────────────────────────────
 * Don't let one observer's failure break others
 */

// ============================================
// COMPARISON WITH OTHER PATTERNS
// ============================================

/**
 * OBSERVER vs MEDIATOR
 * ────────────────────────────
 * Observer: One-to-many, subject broadcasts to all
 * Mediator: Many-to-many through central mediator
 *
 * OBSERVER vs PUB/SUB
 * ────────────────────────────
 * Observer: Direct connection between subject and observers
 * Pub/Sub: Event channel between publishers and subscribers
 *
 * OBSERVER vs CHAIN OF RESPONSIBILITY
 * ────────────────────────────
 * Observer: All observers receive notification
 * Chain: Request passes through chain until handled
 *
 * OBSERVER vs COMMAND
 * ────────────────────────────
 * Observer: Reactive (respond to events)
 * Command: Proactive (encapsulate requests)
 */

// ============================================
// QUICK REFERENCE CHECKLIST
// ============================================

/**
 * IMPLEMENTATION CHECKLIST:
 * ────────────────────────────
 *
 * □ Create Observer interface with update() method
 * □ Create Subject interface with attach/detach/notify methods
 * □ Implement ConcreteSubject with observer array
 * □ Implement ConcreteObservers with update() logic
 * □ In Subject, maintain observers list
 * □ In Subject->attach(), add observer to list
 * □ In Subject->detach(), remove observer from list
 * □ In Subject->notify(), loop and call observer->update()
 * □ In Service, inject Subject
 * □ In Service, attach observers during setup
 * □ In Service, call subject->notify() when event occurs
 * □ Test each observer independently
 * □ Document what each observer does
 *
 * LARAVEL EVENTS CHECKLIST:
 * ────────────────────────────
 *
 * □ Create Event class
 * □ Create Listener classes
 * □ Register in EventServiceProvider
 * □ Fire event with event() or dispatch()
 * □ Add ShouldQueue to listeners if async needed
 * □ Test event firing
 * □ Test each listener independently
 */

// ============================================
// SUMMARY
// ============================================

/**
 * OBSERVER PATTERN IN ONE PAGE:
 * ────────────────────────────
 *
 * WHAT: One object (Subject) notifies many objects (Observers) automatically
 *
 * WHY: Loose coupling, easy to extend, follows SOLID principles
 *
 * WHEN: Multiple actions needed after an event
 *
 * HOW:
 * 1. Subject has array of observers
 * 2. Subject->attach() adds observers
 * 3. Subject->notify() loops through observers
 * 4. Each observer->update() does its job
 *
 * COMPONENTS:
 * - Subject: Publisher (has observers list, notifies all)
 * - Observer: Subscriber (has update method, waits for notification)
 * - Interface: Contract ensuring all observers have update()
 *
 * BENEFITS:
 * ✅ Loose coupling
 * ✅ Easy to extend
 * ✅ Single Responsibility
 * ✅ Open/Closed Principle
 *
 * IN LARAVEL:
 * - Events = Subject
 * - Listeners = Observers
 * - EventServiceProvider = Registration
 * - event() = notify()
 *
 * REMEMBER:
 * Subject doesn't know what observers do
 * Observers don't know about each other
 * One notify() triggers all observers
 *
 * USE WHEN:
 * ✅ 3+ actions after event
 * ✅ Actions might change
 * ✅ Need loose coupling
 * ✅ Event-driven system
 *
 * DON'T USE WHEN:
 * ❌ Only 1-2 actions (overkill)
 * ❌ Simple project
 * ❌ Performance critical
 */
